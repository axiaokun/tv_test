# Kmeans算法
思路：

1. 从样本中随机选取k个样本作为簇中心，然后就是要计算每一个实例点与每一个簇中心的距离（这里我们使用欧式距离），然后根据距离越小越相似的原则，将实例点归为最近的簇中心的那一类。
2. 那么经过这一轮后实例点已经划分到k个直到不同的簇中，接着我们要重新计算簇中心的位置。每个簇中多多少少都会有实例，我们根据簇中的实例计算平均值，将这个平均值作为这个簇中心，直到全部簇中心都更新完。
3. 接着就是重新划分每一个实例点是属于哪一个簇，计算方法还是一样，根据距离决定属于这些新的簇中的哪一个。就这样不断的循环更新实例所属的簇和簇中心。
4. 评定循环停止的标志：达到迭代的最大次数或者是簇中心位置已经保持不变了。也就是经过多次更新后的簇中心已经达到属于这个簇中实例的平均值所决定的位置，且簇内的实例也不在改变了。

这里给出效果理解图，不过图中最开始的簇中心并不是随机选择实例点的。
<img src = "理解图.png">

* 实现

对于开始的随机在实例点中随机选择

```
n_sample, n_featrue = X.shape[0], X.shape[1] # 由于后面需要用到矩阵运算，所以这里使用numpy多维数组
centers = np.zeros((self.k, n_featrue)) # 注意的是要为数组开辟同等维度的空间，不然最后一步会赋值失败。
for i in range(self.k):
    center = X[np.random.randint(n_sample)]
    centers[i] = center
```

下面的更新簇中心也同样要这样做。

对于距离依旧使用求L2范数的函数来求,函数默认求L2范数，因此也不必修改参数。使用该函数求出两次簇中心的变化是否为零来判断迭代是否可以停止。
```
np.linalg.norm()
```

**np.mean()**， 传入要求平均值的矩阵，注意当函数参数axis=0时求出的是每一列的平均值，最后结果就返回一个一维数组。当参数axis=1时，求的是每一行数据的平均数，返回维度为实例数的多维数组。

回顾算法过程就是：
```
初始化簇中心
while循环
    聚类，为每一个实例找出所在的簇（依据：距离最小）
    保留原来的簇中心
    更新簇中心（利用簇中实例点求平均）
    判断簇中心点有没有改变（依据：距离是否为零）
        如果没有或是达到迭代最大次数就停止循环
```